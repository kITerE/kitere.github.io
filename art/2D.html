<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="../js/ppm.js"></script>
<title>EreTIk's Box &raquo; Раскрытие памяти (Memory Disclosure) ядра в современных ОС</title>
<meta name="keywords" content="EreTIk, memory disclosure, windows kernel, linux kernel, syscalls" />
<link rel="stylesheet" type="text/css" href="../style.css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://kitere.github.io/feed.xml" />
<script type="text/javascript" src="../js/syntax_hl/shCore.js"></script>
<script type="text/javascript" src="../js/syntax_hl/shBrushAsm.js"></script>
<script type="text/javascript" src="../js/syntax_hl/shBrushCpp.js"></script>
<script type="text/javascript" src="../js/syntax_hl/shBrushPython.js"></script>
<link type="text/css" rel="stylesheet" href="../shCoreEkBox.css"/>
<script type="text/javascript">SyntaxHighlighter.defaults['toolbar'] = false;</script>
<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
        <div id="wrapper">
            <div id="header">
                <h1>EreTIk's Box</h1>
                <h2>Разработка, исследование и низкоуровневое программирование</h2>
            </div>
        <div id="strap">
<b>EreTIk's Box </b> &raquo; <a href="../Articles.html">Cтатьи, исходники</a> &raquo; Раскрытие памяти (Memory Disclosure) ядра в современных ОС
        </div>
<br /><table align="center" border="0" cellpadding="0" cellspacing="0" width="98%"><tr valign="top"><td>
        <div id="navigation">
            <ul id="menu">
                <li><a href="../index.htm">Стартовая страница</a></li>
                <li><a href="../Articles.html">Cтатьи, исходники</a></li>
                <li><a href="../WinDbg.html">Заметки о WinDbg</a></li>
                <li><a href="../Downloads.html">Скачать</a></li>
                <li><a href="../Links.html">Внешние ссылки</a></li>
                <li><a href="../Overview.html">Обо всем</a></li>
                <li><a href="../Contacts.html">Контакты</a></li>
                <li><a href="../Tools.html" onmouseover="mopen('m_tools')" onmouseout="mclosetime()">Утилиты</a>
                  <script type="text/javascript">
                  <!--
                    nav_tools("../");
                  // -->
                  </script>
                </li>
            </ul>
        </div>
        <div style="clear:both"></div>
</td><td>
        <div id="content">
<a target="_blank" href="https://habr.com/post/415685/"><img src="https://habr.com/images/favicons/favicon-32x32.png" alt="habr: Раскрытие памяти (Memory Disclosure) ядра в современных ОС" align="right" /></a>
            <br />
                <p>
Это <b>копия</b> моего перевода, опубликованного на 
<a target="_blank" href="https://habr.com/post/415685/">habr: Раскрытие памяти (Memory Disclosure) ядра в современных ОС</a>.
                </p>
            <br />
<h1>Disclaimer</h1>
            <br />
                <p>
Эта публикация является переводом части документа 
<a target="_blank" href="https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf">"Detecting Kernel Memory Disclosure with x86 Emulation and Taint Tracking"</a> 
(<a target="_blank" href="https://googleprojectzero.blogspot.com/2018/06/detecting-kernel-memory-disclosure.html">Статья Project Zero</a>) 
от 
<a target="_blank" href="https://j00ru.vexillium.org/about/">Mateusz Jurczyk</a>.
                </p>
                <p>
В переведенной части документа:
                </p>
<ul>
<li>специфика языка программирования C (в рамках проблемы раскрытия памяти)</li>
<li>специфика работы ядер ОС Windows и Linux (в рамках проблемы раскрытия памяти)</li>
<li>значимость раскрытия памяти ядра и влияние на безопасность ОС</li>
<li>существующие методы и техники обнаружения и противодействия раскрытия памяти ядра</li>
</ul>
            <br />
                <p>
Хотя в документе пристально рассматриваются механизмы общения привилегированного 
ядра ОС с пользовательскими приложениями, суть проблемы можно обощить для любой 
передачи данных между различными доменами безопасности: гипервизор — гостевая 
машина, привилегированный системный сервис (демон) — GUI приложение, сетевые 
клиент — сервер и т.д.
                </p>
            <br />
<h1>Введение</h1>
            <br />
                <p>
Одной из задач современных операционных систем является обеспечение разделения 
привилегий между пользовательскими приложениями и ядром ОС. Во-первых к этому 
относится то, что влияние каждой программы на среду выполнения должно быть 
ограничено определенной политикой безопасности, а во вторых то, что программы 
могут получать доступ только к той информации, которую им разрешено читать. 
Второе сложно обеспечить, учитывая свойства языка C (основного языка 
программирования, используемого при разработке ядра), которые делают чрезвычайно 
сложным безопасную передачу данных между различными доменами безопасности.
                </p>
            <br />
                <p>
Современные операционные системы, работающие на платформах x86/x86-64, 
многопоточны и используют клиент-серверную модель, в которой приложения 
пользовательского режима (клиенты) выполняются независимо друг от друга и 
вызывают ядро ОС (сервер) при намерении работать с ресурсом, управляемым 
системой. Механизм, используемый кодом режима пользователя (ring 3) для вызова 
заранее определенного набора функций ядра ОС (ring 0), называется системными 
вызовами (system calls) или (коротко) syscalls. Типичный системный вызов показан 
на рисунке 1:
                </p>
            <br />
                <p>
<img src="../images/memory_disclosure_syscall.png" alt="Рисунок 1: Жизненный цикл системного вызова" />
                </p>
                <p>
Рисунок 1: Жизненный цикл системного вызова.
                </p>
            <br />
                <p>
Очень важно избегать непреднамеренной утечки содержимого памяти ядра при 
взаимодействии с программами пользовательского режима. Существует значительный 
риск раскрытия чувствительных данных ядра ОС. Данные могут неявно передаваться 
в выходных параметрах безопасных (с остальных точек зрения) системных вызовов. 
                </p>
            <br />
                <p>
Раскрытие привилегированной системной памяти происходит, когда ядро ОС возвращает 
регион памяти, больший (избыточного размера), чем необходимо для хранения 
соответствующей информации (содержащейся внутри). Часто избыточные байты содержат 
данные, которые были заполнены в другом контексте, а затем память не была 
предварительно инициализирована, что предотвратило бы распространение информации 
в новые структуры данных.
                </p>
            <br />
<h1>Специфика языка программирования C</h1>
            <br />
                <p>
В этом разделе мы рассмотрим несколько аспектов языка C, которые наиболее важны 
для проблемы раскрытия памяти.
                </p>
            <br />
<h3>Неопределенное состояние неинициализированных переменных</h3>
            <br />
                <p>
Отдельные переменные простых типов (таких, как char или int), а также члены 
структур данных (массивы, структуры и объединения) остаются в неопределенном 
состоянии до первой инициализации (вне зависимости от размещения их на стеке или 
в куче). Соответствующие цитаты из спецификации C11 (ISO/IEC 9899:201x Committee 
Draft N1570, April 2011):
                </p>
            <br />
                <div class="quote">
<p>6.7.9 Initialization</p>
<p> ... </p>
<p>10 If an object that has automatic storage duration is not initialized explicitly, <u>its value is indeterminate</u>.</p>
<p></p>
<p>7.22.3.4 The malloc function</p>
<p>…</p>
<p>2 The malloc function allocates space for an object whose size is specified by size and <u>whose value is indeterminate</u>.</p>
<p></p>
<p>7.22.3.5 The realloc function</p>
<p>…</p>
<p>2 The realloc function deallocates the old object pointed to by ptr and returns a pointer to a new object that has the size specified by size. The contents of the new object shall be the same as that of the old object prior to deallocation, up to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object <u>have indeterminate values</u>.</p>
                </div>
            <br />
                <p>
Наиболее применима к системному коду та часть, что относится к объектам, 
расположенным на стеке, поскольку ядро ОС обычно имеет интерфейсы динамического 
выделения с их собственной семантикой (не обязательно совместимые со стандартной 
библиотекой C, как будет описано далее).
                </p>
            <br />
                <p>
Насколько нам известно, ни один из трех самых популярных компиляторов C для 
Windows и Linux (Microsoft C/C++ Compiler, gcc, LLVM) не создает код, который 
предварительно инициализирует неинициализированные программистом переменные на 
стеке в режиме Release-сборки (или ее эквивалента). Существуют опции компилятора, 
позволяющие помечать фреймы стека специальными байтами - маркерами (/RTCs в 
Microsoft Visual Studio, например) но они не используются в Release-сборках по 
соображениям производительности. В результате неинициализированные переменные на 
стеке <b>наследуют</b> старые значения соответствующих областей памяти.
                </p>
            <br />
                <p>
Рассмотрим пример стандартной реализации вымышленного системного вызова Windows, 
который умножает входное целое на два и возвращает результат умножения 
(листинг 1). Очевидно, что в частном случае (InputValue == 0) переменная 
OutputValue остается неинициализированной и копируется обратно клиенту. Такая 
ошибка позволяет раскрывать четыре байта памяти стека ядра при каждом вызове.
                </p>
            <br />
                <pre class="brush: cpp;">
NTSTATUS NTAPI NtMultiplyByTwo(DWORD InputValue, LPDWORD OutputPointer) {
    DWORD OutputValue;

    if (InputValue != 0) { 
        OutputValue = InputValue * 2;
    }

    *OutputPointer = OutputValue;
    return STATUS_SUCCESS;
}
                </pre>
                <p>
Листинг 1: Раскрытие памяти через неинициализированную локальную переменную.
                </p>
            <br />
                <p>
Утечки через неинициализированную локальную переменную на практике не очень 
распространены: с одной стороны современные компиляторы часто обнаруживают и 
предупреждают о таких проблемах, с другой стороны подобные утечки являются 
функциональными ошибками, которые могут быть обнаружены во время разработки или 
тестирования. Однако второй пример (в листинге 2) показывает, что утечка может 
также происходить через поле структуры.
                </p>
            <br />
                <p>
В этом случае зарезервированное поле структуры никогда явно не используется в 
коде, но все же копируется обратно в пользовательский режим и, следовательно, 
также раскрывает четыре байта памяти ядра вызывающему коду. В этом примере 
отчетливо видно, что инициализация каждого поля каждой структуры, возвращаемой 
клиенту, для всех веток исполнения кода является непростой задачей. Во многих 
случаях принудительная инициализация выглядит нелогично, особенно если это поле 
не играет никакой практической роли. Но именно тот факт, что не 
проинициализированная переменная (или поле структуры) на стеке (или в куче) 
принимает содержимое данных, ранее сохраненных в этой областях памяти (в 
контексте другой операции), лежит в основе проблемы раскрытия памяти ядра.
                </p>
            <br />
                <pre class="brush: cpp;">
typedef struct _SYSCALL_OUTPUT {
    DWORD Sum; 
    DWORD Product; 
    DWORD Reserved;
} SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; 

NTSTATUS NTAPI NtArithOperations(
    DWORD InputValue,
    PSYSCALL_OUTPUT OutputPointer
) { 
    SYSCALL_OUTPUT OutputStruct;

    OutputStruct.Sum = InputValue + 2; 
    OutputStruct.Product = InputValue * 2; 

    RtlCopyMemory(OutputPointer, &amp;OutputStruct, sizeof(SYSCALL_OUTPUT)); 

    return STATUS_SUCCESS;
}
                </pre>
                <p>
Листинг 2: Раскрытие памяти через зарезервированное поле структуры.
                </p>
            <br />
<h3>Выравнивание структур и заполняющие (padding) байты</h3>
            <br />
                <p>
Инициализация всех полей выходной структуры является хорошим началом, чтобы 
избежать раскрытия памяти. Но и этого не достаточно, что бы гарантировать, что в 
низкоуровневом представлении отсутствуют неинициализированные байты. Давайте 
снова обратимся к спецификации C11:
                </p>
            <br />
                <div class="quote">
<p>6.5.3.4 The sizeof and Alignof operators</p>
<p> ... </p>
<p>4 [...] When applied to an operand that has structure or union type, the result is the total number of bytes in such an object, <u>including internal and trailing padding</u>.</p>
<p></p>
<p>6.2.8 Alignment of objects</p>
<p>1 Complete object types have alignment requirements which place <u>restrictions on the addresses at which objects of that type may be allocated</u>. An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. [...]</p>
<p></p>
<p>6.7.2.1 Structure and union specifiers</p>
<p>…</p>
<p>17 <u>There may be unnamed padding at the end of a structure or union</u></p>
                </div>
            <br />
                <p>
То есть компиляторы языка С для x86(-64) архитектур применяют естественное 
выравнивание полей структур (имеющих примитивный тип): каждое такое поле 
выравнивается на N байт, где N - размер поля. Кроме того, целые структуры и 
объединения также выровнены, когда они объявляются в массиве, при этом 
выполняется требование к выравниванию вложенных полей. Чтобы обеспечить 
выравнивание, неявные байты заполнения (padding) вставляются в структуры там, 
где это необходимо. Хотя они не доступны напрямую в исходном коде, эти байты 
также наследуют старые значения из областей памяти и могут передавать информацию 
в пользовательский режим.
                </p>
            <br />
                <p>
В примере из листинга 3 структура SYSCALL_OUTPUT возвращается обратно 
вызывающему коду. Она содержит 4-х и 8-ми байтовые поля, разделенные 4-мя 
байтами заполнения (padding), необходимыми для того, что бы адрес поля LargeSum 
стал кратен 8-ми. Несмотря на то, что оба поля правильно инициализированы, байты 
заполнения (padding) не заданы явно, что опять-таки приводит к раскрытию памяти 
стека ядра. Специфика расположение структуры в памяти показана на рисунке 2.
                </p>
            <br />
                <pre class="brush: cpp;">
typedef struct _SYSCALL_OUTPUT {
    DWORD Sum; 
    QWORD LargeSum;
} SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; 

NTSTATUS NTAPI NtSmallSum(
    DWORD InputValue,
    PSYSCALL_OUTPUT OutputPointer
) { 
    SYSCALL_OUTPUT OutputStruct;

    OutputStruct.Sum = InputValue + 2;
    OutputStruct.LargeSum = 0;

    RtlCopyMemory(OutputPointer, &amp;OutputStruct, sizeof(SYSCALL_OUTPUT)); 

    return STATUS_SUCCESS;
}
                </pre>
                <p>
Листинг 3: Раскрытие памяти через выравнивание структуры.
                </p>
            <br />
                <p>
<img src="../images/memory_disclosure_padding.png" alt="Рисунок 2: Представление структуры в памяти с учетом выравнивания" />
                </p>
                <p>
Рисунок 2: Представление структуры в памяти с учетом выравнивания.
                </p>
            <br />
                <p>
Утечки через выравнивания относительно распространены, так как достаточно много 
выходных параметров системных вызовов представлены структурами. Проблема 
особенно остро встает для 64-х битных платформ, где размер указателей, size_t и 
подобных типов увеличивается с 4 до 8 байт, что приводит к появлению заполнения 
(padding), необходимого для выравнивания полей таких структур.
                </p>
            <br />
                <p>
Поскольку байты заполнения (padding) не могут быть адресованы в исходном коде, 
необходимо использовать memset или аналогичную функцию для сброса всей области 
памяти структуры до инициализации любого из ее полей и копирования ее в 
пользовательский режим, например:
                </p>
                <pre class="brush: cpp;">
    memset(&amp;OutputStruct, 0, sizeof(OutputStruct));
                </pre>
            <br />
                <p>
Тем не менее, Seacord R. C. в своей книге "The CERT C Coding Standard, Second 
Edition: 98 Rules for Developing Safe, Reliable, and Secure Systems. 
Addison-Wesley Professional" 2014 утверждает, что это не идеальное решение, 
поскольку байты заполнения (padding) могут по-прежнему быть <b>сбиты</b> после 
вызова memset, например, как побочный эффект операций со смежными полями. 
Озабоченность может быть оправдана следующим утверждением в спецификации С:
                </p>
            <br />
                <div class="quote">
<p>6.2.6 Representations of types</p>
<p>6.2.6.1 General</p>
<p> ... </p>
<p>6 <u>When a value is stored in an object of structure or union type</u>, including in a member object, the bytes of the object representation that correspond to <u>any padding bytes take unspecified values</u>. [...]</p>
                </div>
            <br />
                <p>
Однако на практике ни один из компиляторов C, которые мы тестировали, не читал и 
не писал за пределами областей памяти явно объявленных полей. Похоже, что это 
мнение разделяют разработчики операционных системы, которые используют memset.
                </p>
            <br />
<h3>Объединения (Unions) и поля разного размера</h3>
            <br />
                <p>
Объединения - еще одна сложная конструкция языка C в контексте общения с менее привилегированным вызывающим кодом. Рассмотрим как спецификация C11 описывает представление объединений в памяти:
                </p>
            <br />
                <div class="quote">
<p>6.2.5 Types</p>
<p> ... </p>
<p>20 Any number of derived types can be constructed from the object and function types, as follows: [...] <u>A union type describes an overlapping nonempty set of member objects</u>, each of which has an optionally specified name and possibly distinct type.</p>
<p></p>
<p>6.7.2.1 Structure and union specifiers</p>
<p> ... </p>
<p>6 As discussed in 6.2.5, a structure is a type consisting of a sequence of members, whose storage is allocated in an ordered sequence, and <u>a union is a type consisting of a sequence of members whose storage overlap</u>. </p>
<p> ... </p>
<p>16 <u>The size of a union is sufficient to contain the largest of its members</u>. The value of at most one of the members can be stored in a union object at any time.</p>
                </div>
            <br />
                <p>
Проблема состоит в том, что если объединение состоит из нескольких полей разного 
размера и явно инициализировано только одно полей меньшего размера, то 
оставшиеся байты, выделенные для размещения больших полей, остаются 
неинициализированными. Давайте рассмотрим пример гипотетического обработчика 
системных вызовов, представленный в листинге 4, вместе с распределением памяти 
объединения SYSCALL_OUTPUT, показанным на рисунке 3.
                </p>
            <br />
                <pre class="brush: cpp;">
typedef union _SYSCALL_OUTPUT {
    DWORD Sum; 
    QWORD LargeSum;
} SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; 

NTSTATUS NTAPI NtSmallSum(
    DWORD InputValue,
    PSYSCALL_OUTPUT OutputPointer
) { 
    SYSCALL_OUTPUT OutputStruct;

    OutputStruct.Sum = InputValue + 2;

    RtlCopyMemory(OutputPointer, &amp;OutputStruct, sizeof(SYSCALL_OUTPUT)); 

    return STATUS_SUCCESS;
}
                </pre>
                <p>
Листинг 4: Раскрытие памяти через частичную инициализацию объединения.
                </p>
            <br />
                <p>
<img src="../images/memory_disclosure_union.png" alt="Рисунок 3: Представление объединения в памяти с учетом выравнивания" />
                </p>
                <p>
Рисунок 3: Представление объединения в памяти с учетом выравнивания.
                </p>
            <br />
                <p>
Получается, что общий размер объединения SYSCALL_OUTPUT составляет 8 байт (из-за 
размера большего поля LargeSum). Тем не менее, функция задает только значение 
меньшего поля, оставляя 4 конечных байта неинициализированными, что впоследствии 
и приводит к утечке их клиентскому приложению.
                </p>
            <br />
                <p>
Безопасная реализация должна устанавливать только поле Sum в пользовательском 
адресном пространстве, а не копировать весь объект с потенциально неиспользуемыми 
областями памяти. Еще один рабочий вариант исправления - вызов функции memset для 
обнуления копии объединения в памяти ядра до установки любого из его полей и 
передачи его обратно в пользовательский режим.
                </p>
            <br />
<h3>Небезопасный sizeof</h3>
            <br />
                <p>
Как показано в двух предыдущих подразделах, использование оператора sizeof может 
напрямую или косвенно способствовать раскрытию памяти ядра, провоцируя 
копирование большего количества данных, чем ранее инициализировалось.
                </p>
            <br />
                <p>
В языке C отсутствует аппарат, необходимый для безопасного переноса данных из 
ядра в пользовательское пространство - или, в более общем плане, между любыми 
разными контекстами безопасности. Язык не содержит метаданных времени 
исполнения, которые могут явно указать, какие байты были установлены в каждой 
структуре данных, которая используется для взаимодействия с ядром ОС. В 
результате ответственность ложиться на программиста, который должен сам 
определять какие части каждого объекта должны быть переданы вызывающему коду. 
Если делать правильно, то нужно написать отдельную функцию безопасного 
копирования для каждой структуры выходных данных, используемых в системных 
вызовах. Что в свою очередь приведет к раздуванию размера кода, ухудшению его 
читаемости и в целом будет утомительной и трудоемкой задачей.
                </p>
            <br />
                <p>
С другой стороны, удобно и просто копировать всю область памяти ядра с помощью 
одного вызова memcpy и аргумента sizeof, и пусть клиент определит, какие части 
выходных данных будут использоваться. Получается, что это этот подход 
используется сегодня в Windows и Linux. А когда обнаруживается конкретный случай 
ѕСЃРєРѕР»СЊРєСѓ Р±Р°Р№С‚С‹ Р·Р°РїРѕР»РЅРµРЅРёСЏ (padding) РЅРµ РјРѕРіСѓС‚ Р±С‹С‚СЊ Р°РґСЂРµСЃРѕРІР°РЅС‹ РІ РёСЃС…РѕРґРЅРѕРј РєРѕРґРµ, 
РЅРµРѕР±С…РѕРґРёРјРѕ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊ memset РёР»Рё Р°РЅР°Р»РѕРіРёС‡РЅСѓСЋ С„СѓРЅРєС†РёСЋ РґР»СЏ СЃР±СЂРѕСЃР° РІСЃРµР№ РѕР±Р»Р°СЃС‚Рё 
РїР°РјСЏС‚Рё СЃС‚СЂСѓРєС‚СѓСЂС‹ РґРѕ РёРЅРёС†РёР°Р»РёР·Р°С†РёРё Р»СЋР±РѕРіРѕ РёР· РµРµ РїРѕР»РµР№ Рё РєРѕРїРёСЂРѕРІР°РЅРёСЏ РµРµ РІ 
РїРѕР»СЊР·РѕРІР°С‚РµР»СЊСЃРєРёР№ СЂРµР¶РёРј, РЅР°РїСЂРёРјРµСЂ:
                </p>
                <pre class="brush: cpp;">
    memset(&amp;OutputStruct, 0, sizeof(OutputStruct));
                </pre>
            <br />
                <p>
РўРµРј РЅРµ РјРµРЅРµРµ, Seacord R. C. РІ СЃРІРѕРµР№ РєРЅРёРіРµ "The CERT C Coding Standard, Second 
Edition: 98 Rules for Developing Safe, Reliable, and Secure Systems. 
Addison-Wesley Professional" 2014 СѓС‚РІРµСЂР¶РґР°РµС‚, С‡С‚Рѕ СЌС‚Рѕ РЅРµ РёРґРµР°Р»СЊРЅРѕРµ СЂРµС€РµРЅРёРµ, 
РїРѕСЃРєРѕР»СЊРєСѓ Р±Р°Р№С‚С‹ Р·Р°РїРѕР»РЅРµРЅРёСЏ (padding) РјРѕРіСѓС‚ РїРѕ-РїСЂРµР¶РЅРµРјСѓ Р±С‹С‚СЊ <b>СЃР±РёС‚С‹</b> РїРѕСЃР»Рµ 
РІС‹Р·РѕРІР° memset, РЅР°РїСЂРёРјРµСЂ, РєР°Рє РїРѕР±РѕС‡РЅС‹Р№ СЌС„С„РµРєС‚ РѕРїРµСЂР°С†РёР№ СЃРѕ СЃРјРµР¶РЅС‹РјРё РїРѕР»СЏРјРё. 
РћР·Р°Р±РѕС‡РµРЅРЅРѕСЃС‚СЊ РјРѕР¶РµС‚ Р±С‹С‚СЊ РѕРїСЂР°РІРґР°РЅР° СЃР»РµРґСѓСЋС‰РёРј СѓС‚РІРµСЂР¶РґРµРЅРёРµРј РІ СЃРїРµС†РёС„РёРєР°С†РёРё РЎ:
                </p>
            <br />
                <div class="quote">
<p>6.2.6 Representations of types</p>
<p>6.2.6.1 General</p>
<p> ... </p>
<p>6 <u>When a value is stored in an object of structure or union type</u>, including in a member object, the bytes of the object representation that correspond to <u>any padding bytes take unspecified values</u>. [...]</p>
                </div>
            <br />
                <p>
РћРґРЅР°РєРѕ РЅР° РїСЂР°РєС‚РёРєРµ РЅРё РѕРґРёРЅ РёР· РєРѕРјРїРёР»СЏС‚РѕСЂРѕРІ C, РєРѕС‚РѕСЂС‹Рµ РјС‹ С‚РµСЃС‚РёСЂРѕРІР°Р»Рё, РЅРµ С‡РёС‚Р°Р» Рё 
РЅРµ РїРёСЃР°Р» Р·Р° РїСЂРµРґРµР»Р°РјРё РѕР±Р»Р°СЃС‚РµР№ РїР°РјСЏС‚Рё СЏРІРЅРѕ РѕР±СЉСЏРІР»РµРЅРЅС‹С… РїРѕР»РµР№. РџРѕС…РѕР¶Рµ, С‡С‚Рѕ СЌС‚Рѕ 
РјРЅРµРЅРёРµ СЂР°Р·РґРµР»СЏСЋС‚ СЂР°Р·СЂР°Р±РѕС‚С‡РёРєРё РѕРїРµСЂР°С†РёРѕРЅРЅС‹С… СЃРёСЃС‚РµРјС‹, РєРѕС‚РѕСЂС‹Рµ РёСЃРїРѕР»СЊР·СѓСЋС‚ memset.
                </p>
            <br />
<h3>РћР±СЉРµРґРёРЅРµРЅРёСЏ (Unions) Рё РїРѕР»СЏ СЂР°Р·РЅРѕРіРѕ СЂР°Р·РјРµСЂР°</h3>
            <br />
                <p>
РћР±СЉРµРґРёРЅРµРЅРёСЏ - РµС‰Рµ РѕРґРЅР° СЃР»РѕР¶РЅР°СЏ РєРѕРЅСЃС‚СЂСѓРєС†РёСЏ СЏР·С‹РєР° C РІ РєРѕРЅС‚РµРєСЃС‚Рµ РѕР±С‰РµРЅРёСЏ СЃ РјРµРЅРµРµ РїСЂРёРІРёР»РµРіРёСЂРѕРІР°РЅРЅС‹Рј РІС‹Р·С‹РІР°СЋС‰РёРј РєРѕРґРѕРј. Р Р°СЃСЃРјРѕС‚СЂРёРј РєР°Рє СЃРїРµС†РёС„РёРєР°С†РёСЏ C11 РѕРїРёСЃС‹РІР°РµС‚ РїСЂРµРґСЃС‚Р°РІР»РµРЅРёРµ РѕР±СЉРµРґРёРЅРµРЅРёР№ РІ РїР°РјСЏС‚Рё:
                </p>
            <br />
                <div class="quote">
<p>6.2.5 Types</p>
<p> ... </p>
<p>20 Any number of derived types can be constructed from the object and function types, as follows: [...] <u>A union type describes an overlapping nonempty set of member objects</u>, each of which has an optionally specified name and possibly distinct type.</p>
<p></p>
<p>6.7.2.1 Structure and union specifiers</p>
<p> ... </p>
<p>6 As discussed in 6.2.5, a structure is a type consisting of a sequence of members, whose storage is allocated in an ordered sequence, and <u>a union is a type consisting of a sequence of members whose storage overlap</u>. </p>
<p> ... </p>
<p>16 <u>The size of a union is sufficient to contain the largest of its members</u>. The value of at most one of the members can be stored in a union object at any time.</p>
                </div>
            <br />
                <p>
РџСЂРѕР±Р»РµРјР° СЃРѕСЃС‚РѕРёС‚ РІ С‚РѕРј, С‡С‚Рѕ РµСЃР»Рё РѕР±СЉРµРґРёРЅРµРЅРёРµ СЃРѕСЃС‚РѕРёС‚ РёР· РЅРµСЃРєРѕР»СЊРєРёС… РїРѕР»РµР№ СЂР°Р·РЅРѕРіРѕ 
СЂР°Р·РјРµСЂР° Рё СЏРІРЅРѕ РёРЅРёС†РёР°Р»РёР·РёСЂРѕРІР°РЅРѕ С‚РѕР»СЊРєРѕ РѕРґРЅРѕ РїРѕР»РµР№ РјРµРЅСЊС€РµРіРѕ СЂР°Р·РјРµСЂР°, С‚Рѕ 
РѕСЃС‚Р°РІС€РёРµСЃСЏ Р±Р°Р№С‚С‹, РІС‹РґРµР»РµРЅРЅС‹Рµ РґР»СЏ СЂР°Р·РјРµС‰РµРЅРёСЏ Р±РѕР»СЊС€РёС… РїРѕР»РµР№, РѕСЃС‚Р°СЋС‚СЃСЏ 
РЅРµРёРЅРёС†РёР°Р»РёР·РёСЂРѕРІР°РЅРЅС‹РјРё. Р”Р°РІР°Р№С‚Рµ СЂР°СЃСЃРјРѕС‚СЂРёРј РїСЂРёРјРµСЂ РіРёРїРѕС‚РµС‚РёС‡РµСЃРєРѕРіРѕ РѕР±СЂР°Р±РѕС‚С‡РёРєР° 
СЃРёСЃС‚РµРјРЅС‹С… РІС‹Р·РѕРІРѕРІ, РїСЂРµРґСЃС‚Р°РІР»РµРЅРЅС‹Р№ РІ Р»РёСЃС‚РёРЅРіРµ 4, РІРјРµСЃС‚Рµ СЃ СЂР°СЃРїСЂРµРґРµР»РµРЅРёРµРј РїР°РјСЏС‚Рё 
РѕР±СЉРµРґРёРЅРµРЅРёСЏ SYSCALL_OUTPUT, РїРѕРєР°Р·Р°РЅРЅС‹Рј РЅР° СЂРёСЃСѓРЅРєРµ 3.
                </p>
            <br />
                <pre class="brush: cpp;">
typedef union _SYSCALL_OUTPUT {
    DWORD Sum; 
    QWORD LargeSum;
} SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; 

NTSTATUS NTAPI NtSmallSum(
    DWORD InputValue,
    PSYSCALL_OUTPUT OutputPointer
) { 
    SYSCALL_OUTPUT OutputStruct;

    OutputStruct.Sum = InputValue + 2;

    RtlCopyMemory(OutputPointer, &amp;OutputStruct, sizeof(SYSCALL_OUTPUT)); 

    return STATUS_SUCCESS;
}
                </pre>
                <p>
Р›РёСЃС‚РёРЅРі 4: Р Р°СЃРєСЂС‹С‚РёРµ РїР°РјСЏС‚Рё С‡РµСЂРµР· С‡Р°СЃС‚РёС‡РЅСѓСЋ РёРЅРёС†РёР°Р»РёР·Р°С†РёСЋ РѕР±СЉРµРґРёРЅРµРЅРёСЏ.
                </p>
            <br />
                <p>
<img src="../images/memory_disclosure_union.png" alt="Р РёСЃСѓРЅРѕРє 3: РџСЂРµРґСЃС‚Р°РІР»РµРЅРёРµ РѕР±СЉРµРґРёРЅРµРЅРёСЏ РІ РїР°РјСЏС‚Рё СЃ СѓС‡РµС‚РѕРј РІС‹СЂР°РІРЅРёРІР°РЅРёСЏ" />
                </p>
                <p>
Р РёСЃСѓРЅРѕРє 3: РџСЂРµРґСЃС‚Р°РІР»РµРЅРёРµ РѕР±СЉРµРґРёРЅРµРЅРёСЏ РІ РїР°РјСЏС‚Рё СЃ СѓС‡РµС‚РѕРј РІС‹СЂР°РІРЅРёРІР°РЅРёСЏ.
                </p>
            <br />
                <p>
РџРѕР»СѓС‡Р°РµС‚СЃСЏ, С‡С‚Рѕ РѕР±С‰РёР№ СЂР°Р·РјРµСЂ РѕР±СЉРµРґРёРЅРµРЅРёСЏ SYSCALL_OUTPUT СЃРѕСЃС‚Р°РІР»СЏРµС‚ 8 Р±Р°Р№С‚ (РёР·-Р·Р° 
СЂР°Р·РјРµСЂР° Р±РѕР»СЊС€РµРіРѕ РїРѕР»СЏ LargeSum). РўРµРј РЅРµ РјРµРЅРµРµ, С„СѓРЅРєС†РёСЏ Р·Р°РґР°РµС‚ С‚РѕР»СЊРєРѕ Р·РЅР°С‡РµРЅРёРµ 
РјРµРЅСЊС€РµРіРѕ РїРѕР»СЏ, РѕСЃС‚Р°РІР»СЏСЏ 4 РєРѕРЅРµС‡РЅС‹С… Р±Р°Р№С‚Р° РЅРµРёРЅРёС†РёР°Р»РёР·РёСЂРѕРІР°РЅРЅС‹РјРё, С‡С‚Рѕ РІРїРѕСЃР»РµРґСЃС‚РІРёРё 
Рё РїСЂРёРІРѕРґРёС‚ Рє СѓС‚РµС‡РєРµ РёС… РєР»РёРµРЅС‚СЃРєРѕРјСѓ РїСЂРёР»РѕР¶РµРЅРёСЋ.
                </p>
            <br />
                <p>
Р‘РµР·РѕРїР°СЃРЅР°СЏ СЂРµР°Р»РёР·Р°С†РёСЏ РґРѕР»Р¶РЅР° СѓСЃС‚Р°РЅР°РІР»РёРІР°С‚СЊ С‚РѕР»СЊРєРѕ РїРѕР»Рµ Sum РІ РїРѕР»СЊР·РѕРІР°С‚РµР»СЊСЃРєРѕРј 
Р°РґСЂРµСЃРЅРѕРј РїСЂРѕСЃС‚СЂР°РЅСЃС‚РІРµ, Р° РЅРµ РєРѕРїРёСЂРѕРІР°С‚СЊ РІРµСЃСЊ РѕР±СЉРµРєС‚ СЃ РїРѕС‚РµРЅС†РёР°Р»СЊРЅРѕ РЅРµРёСЃРїРѕР»СЊР·СѓРµРјС‹РјРё 
РѕР±Р»Р°СЃС‚СЏРјРё РїР°РјСЏС‚Рё. Р•С‰Рµ РѕРґРёРЅ СЂР°Р±РѕС‡РёР№ РІР°СЂРёР°РЅС‚ РёСЃРїСЂР°РІР»РµРЅРёСЏ - РІС‹Р·РѕРІ С„СѓРЅРєС†РёРё memset РґР»СЏ 
РѕР±РЅСѓР»РµРЅРёСЏ РєРѕРїРёРё РѕР±СЉРµРґРёРЅРµРЅРёСЏ РІ РїР°РјСЏС‚Рё СЏРґСЂР° РґРѕ СѓСЃС‚Р°РЅРѕРІРєРё Р»СЋР±РѕРіРѕ РёР· РµРіРѕ РїРѕР»РµР№ Рё 
РїРµСЂРµРґР°С‡Рё РµРіРѕ РѕР±СЂР°С‚РЅРѕ РІ РїРѕР»СЊР·РѕРІР°С‚РµР»СЊСЃРєРёР№ СЂРµР¶РёРј.
                </p>
            <br />
<h3>РќРµР±РµР·РѕРїР°СЃРЅС‹Р№ sizeof</h3>
            <br />
                <p>
РљР°Рє РїРѕРєР°Р·Р°РЅРѕ РІ РґРІСѓС… РїСЂРµРґС‹РґСѓС‰РёС… РїРѕРґСЂР°Р·РґРµР»Р°С…, РёСЃРїРѕР»СЊР·РѕРІР°РЅРёРµ РѕРїРµСЂР°С‚РѕСЂР° sizeof РјРѕР¶РµС‚ 
РЅР°РїСЂСЏРјСѓСЋ РёР»Рё РєРѕСЃРІРµРЅРЅРѕ СЃРїРѕСЃРѕР±СЃС‚РІРѕРІР°С‚СЊ СЂР°СЃРєСЂС‹С‚РёСЋ РїР°РјСЏС‚Рё СЏРґСЂР°, РїСЂРѕРІРѕС†РёСЂСѓСЏ 
РєРѕРїРёСЂРѕРІР°РЅРёРµ Р±РѕР»СЊС€РµРіРѕ РєРѕР»РёС‡РµСЃС‚РІР° РґР°РЅРЅС‹С…, С‡РµРј СЂР°РЅРµРµ РёРЅРёС†РёР°Р»РёР·РёСЂРѕРІР°Р»РѕСЃСЊ.
                </p>
            <br />
                <p>
Р’ СЏР·С‹РєРµ C РѕС‚СЃСѓС‚СЃС‚РІСѓРµС‚ Р°РїРїР°СЂР°С‚, РЅРµРѕР±С…РѕРґРёРјС‹Р№ РґР»СЏ Р±РµР·РѕРїР°СЃРЅРѕРіРѕ РїРµСЂРµРЅРѕСЃР° РґР°РЅРЅС‹С… РёР· 
СЏРґСЂР° РІ РїРѕР»СЊР·РѕРІР°С‚РµР»СЊСЃРєРѕРµ РїСЂРѕСЃС‚СЂР°РЅСЃС‚РІРѕ - РёР»Рё, РІ Р±РѕР»РµРµ РѕР±С‰РµРј РїР»Р°РЅРµ, РјРµР¶РґСѓ Р»СЋР±С‹РјРё 
СЂР°Р·РЅС‹РјРё РєРѕРЅС‚РµРєСЃС‚Р°РјРё Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё. РЇР·С‹Рє РЅРµ СЃРѕРґРµСЂР¶РёС‚ РјРµС‚Р°РґР°РЅРЅС‹С… РІСЂРµРјРµРЅРё 
РёСЃРїРѕР»РЅРµРЅРёСЏ, РєРѕС‚РѕСЂС‹Рµ РјРѕРіСѓС‚ СЏРІРЅРѕ СѓРєР°Р·Р°С‚СЊ, РєР°РєРёРµ Р±Р°Р№С‚С‹ Р±С‹Р»Рё СѓСЃС‚Р°РЅРѕРІР»РµРЅС‹ РІ РєР°Р¶РґРѕР№ 
СЃС‚СЂСѓРєС‚СѓСЂРµ РґР°РЅРЅС‹С…, РєРѕС‚РѕСЂР°СЏ РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ РґР»СЏ РІР·Р°РёРјРѕРґРµР№СЃС‚РІРёСЏ СЃ СЏРґСЂРѕРј РћРЎ. Р’ 
СЂРµР·СѓР»СЊС‚Р°С‚Рµ РѕС‚РІРµС‚СЃС‚РІРµРЅРЅРѕСЃС‚СЊ Р»РѕР¶РёС‚СЊСЃСЏ РЅР° РїСЂРѕРіСЂР°РјРјРёСЃС‚Р°, РєРѕС‚РѕСЂС‹Р№ РґРѕР»Р¶РµРЅ СЃР°Рј 
РѕРїСЂРµРґРµР»СЏС‚СЊ РєР°РєРёРµ С‡Р°СЃС‚Рё РєР°Р¶РґРѕРіРѕ РѕР±СЉРµРєС‚Р° РґРѕР»Р¶РЅС‹ Р±С‹С‚СЊ РїРµСЂРµРґР°РЅС‹ РІС‹Р·С‹РІР°СЋС‰РµРјСѓ РєРѕРґСѓ. 
Р•СЃР»Рё РґРµР»Р°С‚СЊ РїСЂР°РІРёР»СЊРЅРѕ, С‚Рѕ РЅСѓР¶РЅРѕ РЅР°РїРёСЃР°С‚СЊ РѕС‚РґРµР»СЊРЅСѓСЋ С„СѓРЅРєС†РёСЋ Р±РµР·РѕРїР°СЃРЅРѕРіРѕ 
РєРѕРїРёСЂРѕРІР°РЅРёСЏ РґР»СЏ РєР°Р¶РґРѕР№ СЃС‚СЂСѓРєС‚СѓСЂС‹ РІС‹С…РѕРґРЅС‹С… РґР°РЅРЅС‹С…, РёСЃРїРѕР»СЊР·СѓРµРјС‹С… РІ СЃРёСЃС‚РµРјРЅС‹С… 
РІС‹Р·РѕРІР°С…. Р§С‚Рѕ РІ СЃРІРѕСЋ РѕС‡РµСЂРµРґСЊ РїСЂРёРІРµРґРµС‚ Рє СЂР°Р·РґСѓРІР°РЅРёСЋ СЂР°Р·РјРµСЂР° РєРѕРґР°, СѓС…СѓРґС€РµРЅРёСЋ РµРіРѕ 
С‡РёС‚Р°РµРјРѕСЃС‚Рё Рё РІ С†РµР»РѕРј Р±СѓРґРµС‚ СѓС‚РѕРјРёС‚РµР»СЊРЅРѕР№ Рё С‚СЂСѓРґРѕРµРјРєРѕР№ Р·Р°РґР°С‡РµР№.
                </p>
            <br />
                <p>
РЎ РґСЂСѓРіРѕР№ СЃС‚РѕСЂРѕРЅС‹, СѓРґРѕР±РЅРѕ Рё РїСЂРѕСЃС‚Рѕ РєРѕРїРёСЂРѕРІР°С‚СЊ РІСЃСЋ РѕР±Р»Р°СЃС‚СЊ РїР°РјСЏС‚Рё СЏРґСЂР° СЃ РїРѕРјРѕС‰СЊСЋ 
РѕРґРЅРѕРіРѕ РІС‹Р·РѕРІР° memcpy Рё Р°СЂРіСѓРјРµРЅС‚Р° sizeof, Рё РїСѓСЃС‚СЊ РєР»РёРµРЅС‚ РѕРїСЂРµРґРµР»РёС‚, РєР°РєРёРµ С‡Р°СЃС‚Рё 
РІС‹С…РѕРґРЅС‹С… РґР°РЅРЅС‹С… Р±СѓРґСѓС‚ РёСЃРїРѕР»СЊР·РѕРІР°С‚СЊСЃСЏ. РџРѕР»СѓС‡Р°РµС‚СЃСЏ, С‡С‚Рѕ СЌС‚Рѕ СЌС‚РѕС‚ РїРѕРґС…РѕРґ 
РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ СЃРµРіРѕРґРЅСЏ РІ Windows Рё Linux. Рђ РєРѕРіРґР° РѕР±РЅР°СЂСѓР¶РёРІР°РµС‚СЃСЏ РєРѕРЅРєСЂРµС‚РЅС‹Р№ СЃР»СѓС‡Р°Р№ 
ORD KernelBuffer = Allocate(OutputLength);

    KernelBuffer[0] = 0xdeadbeef;
    KernelBuffer[1] = 0xbadc0ffe;
    KernelBuffer[2] = 0xcafed00d;

    RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength);
    Free(KernelBuffer);

    return STATUS_SUCCESS;
}
                </pre>
                <p>
Листинг 6: Раскрытие памяти через выходной буфер произвольного размера.
                </p>
            <br />
                <p>
Целью системного вызова является предоставление вызывающему коду трех специальных 
32-х битных значений, занимающих в общей сложности 12 байт. Хотя проверка 
правильности размера буфера в самом начале функции верна, использование аргумента 
OutputLength должно на этом и заканчиваться. Зная, что выходной буфер имеет 
достаточный размер, чтобы сохранить результат, ядро может выделить 12 байт памяти, 
заполнить ее и скопировать содержимое обратно в предоставленный буфер 
пользовательского режима. А вместо этого системный вызов выделяет блок пула (причем 
с контролируемой пользователем длиной) и копирует выделенную память целиком в 
пользовательское пространство. Получается, что все байты, кроме первых 12-ти, не 
инициализируются и ошибочно раскрываются пользователю, как показано на рисунке 5.
                </p>
            <br />
                <p>
<img src="../images/memory_disclosure_outsize.png" alt="Рисунок 5: Память буфера произвольного размера" />
                </p>
                <p>
Рисунок 5: Память буфера произвольного размера.
                </p>
            <br />
                <p>
Схема, обсуждаемая в этом разделе, особенно характерна для Windows. Подобная 
ошибка может предоставить злоумышленнику чрезвычайно полезный примитив для 
раскрытия памяти:
                </p>
            <ul>
                <li>
Оптимизация, часто используемая в системных вызовах Windows, заключается в 
использовании буферов на основе стека для небольших размеров и выделение памяти 
из пулов для более крупных. В сочетании с подобной утечкой это может облегчить 
раскрытие как стека ядра, так и пула с помощью одной уязвимости.
                </li>
                <li>
Возможность контролировать размер раскрываемых данных из пула дает злоумышленнику 
возможность управлять типом конфиденциальной информации. Это становится возможным, 
учитывая современные механизмы распределения памяти, имеющие тенденцию к 
кэшированию областей памяти для последующих запросов выделения памяти с тем же 
размером буфера. Что дает возможность читать специфические данные, недавно 
освобожденные другим (в общем случае - не связанным) компонентом ядра.
                </li>
            </ul>
            <br />
                <p>
Таким образом, это один из самых опасных типов раскрытия информации. Безопасная 
реализация должна отслеживать количество байтов, записанных во временное хранилище 
ядра, и передавая только этот объем данных клиенту.
                </p>
            <br />
<h1>Факторы, способствующие появлению ошибок раскрытия памяти</h1>
            <br />
                <p>
Здесь мы расскажем о том, какие существуют проблемы с выявлением ошибок раскрытия 
памяти в ходе разработки. Что в течение многих лет способствовало отсутствию 
признания проблемы, что в свою очередь привело к нагромождению в ядре Windows 
десятков ошибок раскрытия памяти.
                </p>
            <br />
<h4>Отсутствие видимых последствий</h4>
                <p>
Как правило, ошибки раскрытия информации более сложны для обнаружения, чем 
нарушения памяти. Последние обычно проявляются в виде сбоев программного 
обеспечения, особенно в сочетании со специализированными механизмами: 
<a target="_blank" href="https://en.wikipedia.org/wiki/AddressSanitizer">AddressSanitizer</a>, 
<a target="_blank" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/enable-page-heap">PageHeap</a> 
или <a target="_blank" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/special-pool">Special Pool</a>. 
Раскрытие информации, напротив, не вызывает каких-либо наблюдаемых проблем и не 
может быть легко распознано программными решениями. Конфиденциальность любой 
информации очень субъективна и требуется оценка человеком, что бы определить 
легитимность предоставленной информации в контексте безопасности. С другой 
стороны, когда гигабайты траффика передаются между ядром и пользовательским 
пространством, из памяти программ в файлы на диск, с одной машины на другую через 
сеть и между контекстами безопасности, не представляется возможным вручную 
просмотреть весь этот трафик, что бы найти случаи ошибок раскрытия памяти. В 
результате многие ошибки могут активно *сливать* данных в течение многих лет, 
прежде чем они будут замечены (если вообще будут замечены).
                </p>
            <br />
                <p>
Тот факт, что уведомление о подобных утечках не дает ощутимой обратной связи 
от разработчиков ядра, также означает, что они не учатся на своих ошибках. И что 
они будут повторять одни и те же небезопасные шаблоны кода в нескольких местах, 
так как они не знают об этом классе ошибок и не предпринимают действий к 
предотвращению возникновение подобных проблем.
                </p>
            <br />
<h4>Утечки, скрытые за системным API</h4>
                <p>
Типичные клиентские приложения реализуют свою функциональность с использованием 
высокоуровневого системного API, особенно в Windows (Win32/User32 API). API 
часто отвечает за преобразование входных параметров во внутренние структуры, 
принятые системными вызовами, и аналогичным образом преобразует выходные данные 
системных вызовов в формат, понятный вызывающему коду клиентского приложения. В 
этом случае содержимое памяти, раскрываемое ядром, может быть отброшено системной 
библиотекой пользовательского режима и, следовательно, никогда не будет передана 
обратно программе. Это еще больше уменьшает видимость утечек и снижает вероятность 
их обнаружения при разработке *обычного* программного обеспечения.
                </p>
            <br />
<h1>Значимость и влияние на безопасность системы</h1>
            <br />
                <p>
По своей природе, утечки памяти памяти ядра в пользовательское пространство 
являются сугубо локальными ошибками раскрытия информации. Они не приводят к порче 
памяти или эксплуатации удаленного исполнения, а злоумышленник уже должен иметь 
возможность исполнения произвольного кода на целевой машине. Но с другой стороны 
стоит учитывать, что большинство раскрытий совершаются *молча* и не оставляют 
никаких следов в системе, что позволяет практически бесконечно эксплуатировать 
подобные ошибки, пока не будет достигнута цель эксплойта. Серьезность проблемы 
должна оцениваться в каждом конкретном случае, поскольку она зависит от степени 
утечки и типа данных, которые могут быть раскрыты.
                </p>
            <br />
                <p>
В общем, класс подобных ошибок кажется вполне полезным, как одно из звеньев в 
длинной цепочке локального повышения привилегий. В настоящее время основная 
техника, которая основана на неразглашении данных это KASLR 
(Kernel Address Space Layout Randomization), а расположение различных объектов в 
адресном пространстве ядра является одним из самых распространенных типов утечек 
данных. Реальный пример: эксплойт ядра Windows, обнаруженный в дампе Hacking Team 
в июле 2015 года 
(<a target="_blank" href="https://blog.rapid7.com/2015/08/14/revisiting-an-info-leak/">Juan Vazquez. Revisiting an Info Leak</a>) 
в котором использовалось раскрытие памяти пула для определения (derandomize) 
базового адреса загрузки драйвера win32k.sys, впоследствии используемого для 
применения в другой уязвимости. Кстати, этот же дефект был обнаружен в тоже время 
Matt Tait'ом из Google Project Zero 
(<a target="_blank" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=480">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a>) 
и исправлен в бюллетене MS15-080 (CVE-2015-2433).
                </p>
            <br />
<h4>Стеки</h4>
                <p>
Различие между стеком и динамической памятью (пулы/кучи) заключается в том, что 
в стеках обычно хранятся данные, связанные непосредственно с потоком управления 
(control flow), такие как: адреса модулей ядра, адреса динамической памяти, и 
секретные значения, установленные механизмами безопасности, такими как StackGuard на Linux и 
<a target="_blank" href="https://msdn.microsoft.com/en-us/library/8dbf701c.aspx">/GS на Windows</a>. 
Это значимые фрагменты информации, которые могут быть немедленно применены 
потенциальным злоумышленником в совокупности с эксплоитами порчи памяти. Тем не 
менее разнообразие данных на стеке ограничено, что позволяет предположить, что 
эксплуатация утечки стека не представляет большой ценности в виде автономной уязвимости.
                </p>
            <br />
<h4>Динамическая память (пулы/кучи)</h4>
                <p>
Динамическая память ядра (пулы/кучи) содержит адреса исполняемых модулей, адреса 
динамически выделенной памяти, а так же ряд конфиденциальных данных, 
обрабатываемых различными компонентами системы: дисковыми драйверами, драйверами 
файловых систем, сетевыми драйверами, драйверами видео и так далее. Утечка этой 
информации позволяет злоумышленнику эффективно следить за деятельностью привилегированных 
сервисов и других пользователей системы, потенциально получая содержимое конфиденциальных 
данных, которые имеют ценность сами по себе. Плюс полученные данные могут использоваться 
при эксплуатации другой ошибки. В целом, проблема эксплуатируемой утечки конкретных 
типов данных из ядра (содержимого файлов, сетевого трафика или паролей) остается открытой 
и, к сожалению, она не исследована в должной мере.
                </p>
            <br />
<h1>Другие существующие исследования</h1>
                <p>
<img src="../images/memory_leaks.jpg" alt="КДПВ" />
                </p>
            <br />
<h3>Microsoft Windows</h3>
            <br />
<h4>Обнаружение</h4>
                <p>
До 2015 года в публичных источниках практически не обсуждалась проблема раскрытия 
памяти в Windows. В июле 2015 года Matt Tait сообщил о проблеме раскрытия 
неинициализированной памяти пула чР…РЎС“Р В»Р ВµР Р…Р С‘РЎРЏ Р С”Р С•Р С—Р С‘Р С‘ Р С•Р В±РЎР‰Р ВµР Т‘Р С‘Р Р…Р ВµР Р…Р С‘РЎРЏ Р Р† Р С—Р В°Р С